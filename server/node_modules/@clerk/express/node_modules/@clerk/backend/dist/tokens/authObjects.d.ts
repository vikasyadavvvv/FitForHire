import type { CheckAuthorizationFromSessionClaims, Jwt, JwtPayload, PendingSessionOptions, ServerGetToken, SessionStatusClaim, SharedSignedInAuthObjectProperties } from '@clerk/types';
import type { CreateBackendApiOptions } from '../api';
import type { AuthenticateContext } from './authenticateContext';
import type { MachineTokenType, SessionTokenType } from './tokenTypes';
import type { MachineAuthType } from './types';
/**
 * @inline
 */
type AuthObjectDebugData = Record<string, any>;
/**
 * @inline
 */
type AuthObjectDebug = () => AuthObjectDebugData;
type Claims = Record<string, any>;
/**
 * @internal
 */
export type SignedInAuthObjectOptions = CreateBackendApiOptions & {
    token: string;
};
/**
 * @internal
 */
export type SignedInAuthObject = SharedSignedInAuthObjectProperties & {
    /**
     * The allowed token type.
     */
    tokenType: SessionTokenType;
    /**
     * A function that gets the current user's [session token](https://clerk.com/docs/backend-requests/resources/session-tokens) or a [custom JWT template](https://clerk.com/docs/backend-requests/jwt-templates).
     */
    getToken: ServerGetToken;
    /**
     * A function that checks if the user has an organization role or custom permission.
     */
    has: CheckAuthorizationFromSessionClaims;
    /**
     * Used to help debug issues when using Clerk in development.
     */
    debug: AuthObjectDebug;
};
/**
 * @internal
 */
export type SignedOutAuthObject = {
    sessionClaims: null;
    sessionId: null;
    sessionStatus: SessionStatusClaim | null;
    actor: null;
    tokenType: SessionTokenType;
    userId: null;
    orgId: null;
    orgRole: null;
    orgSlug: null;
    orgPermissions: null;
    factorVerificationAge: null;
    getToken: ServerGetToken;
    has: CheckAuthorizationFromSessionClaims;
    debug: AuthObjectDebug;
};
/**
 * Extended properties specific to each machine token type.
 * While all machine token types share common properties (id, name, subject, etc),
 * this type defines the additional properties that are unique to each token type.
 *
 * @example
 * api_key & machine_token: adds `claims` property
 * oauth_token: adds no additional properties (empty object)
 *
 * @template TAuthenticated - Whether the machine object is authenticated or not
 */
type MachineObjectExtendedProperties<TAuthenticated extends boolean> = {
    api_key: {
        name: TAuthenticated extends true ? string : null;
        claims: TAuthenticated extends true ? Claims | null : null;
    };
    machine_token: {
        name: TAuthenticated extends true ? string : null;
        claims: TAuthenticated extends true ? Claims | null : null;
    };
    oauth_token: object;
};
/**
 * @internal
 */
export type AuthenticatedMachineObject<T extends MachineTokenType = MachineTokenType> = {
    id: string;
    subject: string;
    scopes: string[];
    getToken: () => Promise<string>;
    has: CheckAuthorizationFromSessionClaims;
    debug: AuthObjectDebug;
    tokenType: T;
} & MachineObjectExtendedProperties<true>[T];
/**
 * @internal
 */
export type UnauthenticatedMachineObject<T extends MachineTokenType = MachineTokenType> = {
    id: null;
    subject: null;
    scopes: null;
    getToken: () => Promise<null>;
    has: CheckAuthorizationFromSessionClaims;
    debug: AuthObjectDebug;
    tokenType: T;
} & MachineObjectExtendedProperties<false>[T];
/**
 * @interface
 */
export type AuthObject = SignedInAuthObject | SignedOutAuthObject | AuthenticatedMachineObject | UnauthenticatedMachineObject;
/**
 * @internal
 */
export declare function signedInAuthObject(authenticateContext: Partial<AuthenticateContext>, sessionToken: string, sessionClaims: JwtPayload): SignedInAuthObject;
/**
 * @internal
 */
export declare function signedOutAuthObject(debugData?: AuthObjectDebugData, initialSessionStatus?: SessionStatusClaim): SignedOutAuthObject;
/**
 * @internal
 */
export declare function authenticatedMachineObject<T extends MachineTokenType>(tokenType: T, token: string, verificationResult: MachineAuthType, debugData?: AuthObjectDebugData): AuthenticatedMachineObject<T>;
/**
 * @internal
 */
export declare function unauthenticatedMachineObject<T extends MachineTokenType>(tokenType: T, debugData?: AuthObjectDebugData): UnauthenticatedMachineObject<T>;
/**
 * Auth objects moving through the server -> client boundary need to be serializable
 * as we need to ensure that they can be transferred via the network as pure strings.
 * Some frameworks like Remix or Next (/pages dir only) handle this serialization by simply
 * ignoring any non-serializable keys, however Nextjs /app directory is stricter and
 * throws an error if a non-serializable value is found.
 *
 * @internal
 */
export declare const makeAuthObjectSerializable: <T extends Record<string, unknown>>(obj: T) => T;
/**
 * @internal
 */
export declare const getAuthObjectFromJwt: (jwt: Jwt, { treatPendingAsSignedOut, ...options }: PendingSessionOptions & Partial<AuthenticateContext>) => SignedInAuthObject | SignedOutAuthObject;
export {};
//# sourceMappingURL=authObjects.d.ts.map